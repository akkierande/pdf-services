<questionbank group="Design patterns">
	<category name="Gang of four">
		<qa id="1" rating="2">			<question><![CDATA[q: Design patterns (GoF)]]></question>
			<answer><![CDATA[Design patterns are recurring solutions to software design problems you find again and again in real-world application development. Patterns are about design and interaction of objects, as well as providing a communication platform concerning elegant, reusable solutions to commonly encountered programming challenges.<br/>

The Gang of Four (GoF) patterns are generally considered the foundation for all other patterns. They are categorized in three groups: Creational, Structural, and Behavioral. Here you will find information on these important patterns.]]></answer>
		</qa>
		<qa id="2" rating="2">			<question><![CDATA[q: Creational Patterns]]></question>
			<answer><![CDATA[<ul>
<li>  <b>Singleton</b> : A class of which only a single instance can exist <br/><img src="http://www.dofactory.com/Patterns/Diagrams/singleton.gif"/></li>
<li>  <b>Factory Method</b> : Creates an instance of several derived classes <br/><img src="http://www.dofactory.com/Patterns/Diagrams/factory.gif"/></li>
<li>  <b>Abstract Factory</b> : Creates an instance of several families of classes <br/><img src="http://www.dofactory.com/Patterns/Diagrams/abstract.gif"/></li>
<li>  <b>Builder</b> : Separates object construction from its representation <br/><img src="http://www.dofactory.com/Patterns/Diagrams/builder.gif"/></li>
<li>  <b>Prototype</b> : A fully initialized instance to be copied or cloned <br/><img src="http://www.dofactory.com/Patterns/Diagrams/prototype.gif"/></li>
</ul>]]></answer>
		</qa>
		<qa id="3" rating="2">			<question><![CDATA[q: Structural  Patterns]]></question>
			<answer><![CDATA[<ul>
<li><b>Adapter</b> : Match interfaces of different classes <br/><img src="http://www.dofactory.com/Patterns/Diagrams/adapter.gif"/></li>
<li><b>Bridge</b> : Separates an object's interface from its implementation <br/><img src="http://www.dofactory.com/Patterns/Diagrams/bridge.gif"/></li>
<li><b>Composite</b> : A tree structure of simple and composite objects <br/><img src="http://www.dofactory.com/Patterns/Diagrams/composite.gif"/></li>
<li><b>Decorator</b> : Add responsibilities to objects dynamically <br/><img src="http://www.dofactory.com/Patterns/Diagrams/decorator.gif"/></li>
<li><b>Facade</b> : A single class that represents an entire subsystem <br/><img src="http://www.dofactory.com/Patterns/Diagrams/facade.gif"/></li>
<li><b>Flyweight</b> : A fine-grained instance used for efficient sharing <br/><img src="http://www.dofactory.com/Patterns/Diagrams/flyweight.gif"/></li>
<li><b>Proxy</b> : An object representing another object <br/><img src="http://www.dofactory.com/Patterns/Diagrams/proxy.gif"/></li>
</ul>]]></answer>
		</qa>
		<qa id="4" rating="2">			<question><![CDATA[q: Behavioral Patterns]]></question>
			<answer><![CDATA[<ul>
<li><b>Chain of Resp.</b> : A way of passing a request between a chain of objects<br/><img src="http://www.dofactory.com/Patterns/Diagrams/chain.gif"/></li>
<li><b>Command</b> : Encapsulate a command request as an object<br/><img src="http://www.dofactory.com/Patterns/Diagrams/command.gif"/></li>
<li><b>Interpreter</b> : A way to include language elements in a program<br/><img src="http://www.dofactory.com/Patterns/Diagrams/interpreter.gif"/></li>
<li><b>Iterator</b> : Sequentially access the elements of a collection<br/><img src="http://www.dofactory.com/Patterns/Diagrams/iterator.gif"/></li>
<li><b>Mediator</b> : Defines simplified communication between classes<br/><img src="http://www.dofactory.com/Patterns/Diagrams/mediator.gif"/></li>
<li><b>Memento</b> : Capture and restore an object's internal state<br/><img src="http://www.dofactory.com/Patterns/Diagrams/memento.gif"/></li>
<li><b>Observer</b> : A way of notifying change to a number of classes<br/><img src="http://www.dofactory.com/Patterns/Diagrams/observer.gif"/></li>
<li><b>State</b> : Alter an object's behavior when its state changes<br/><img src="http://www.dofactory.com/Patterns/Diagrams/state.gif"/></li>
<li><b>Strategy</b> : Encapsulates an algorithm inside a class<br/><img src="http://www.dofactory.com/Patterns/Diagrams/strategy.gif"/></li>
<li><b>Template Method</b> : Defer the exact steps of an algorithm to a subclass<br/><img src="http://www.dofactory.com/Patterns/Diagrams/template.gif"/></li>
<li><b>Visitor</b> : Defines a new operation to a class without change<br/><img src="http://www.dofactory.com/Patterns/Diagrams/visitor.gif"/></li>
</ul>]]></answer>
		</qa>
	</category>
	<category name="j2ee patterns">
		<qa id="5" rating="2">			<question><![CDATA[q:J2ee patterns at a glance]]></question>
			<answer><![CDATA[<img src="http://www.corej2eepatterns.com/images/CJP2Catalog.gif"/> <br/>
ref: <a href="www.corej2eepatterns.com"/>]]></answer>
		</qa>
		<qa id="6" rating="2">			<question><![CDATA[q: Explain j2ee patterns]]></question>
			<answer><![CDATA[<ul>
<li><b>Intercepting Filter</b> intercepts incoming requests and outgoing responses and applies a filter. These filters may be added and removed in a declarative manner, allowing them to be applied unobtrusively in a variety of combinations. After this preprocessing and/or post-processing is complete, the final filter in the group vectors control to the original target object. For an incoming request, this is often a Front Controller, but may be a View.<br/></li>
<li><b>Front Controller</b> is a container to hold the common processing logic that occurs within the presentation tier and that may otherwise be erroneously placed in a View. A controller handles requests and manages content retrieval, security, view management, and navigation, delegating to a Dispatcher component to dispatch to a View.<br/></li>
<li><b>Application Controller</b> centralizes control, retrieval, and invocation of view and command processing. While a Front Controller acts as a centralized access point and controller for incoming requests, the Application Controller is responsible for identifying and invoking commands, and for identifying and dispatching to views.<br/></li>
<li><b>Context Object</b> encapsulates state in a protocol-independent way to be shared throughout your application. Using Context Object makes testing easier, facilitating a more generic test environment with reduced dependence upon a specific container.<br/></li>
<li><b>View Helper</b> encourages the separation of formatting-related code from other business logic. It suggests using Helper components to encapsulate logic relating to initiating content retrieval, validation, and adapting and formatting the model. The View component is then left to encapsulate the presentation formatting. Helper components typically delegate to the business services via a Business Delegate or an Application Service, while a View may be composed of multiple subcomponents to create its template.<br/></li>
<li><b>Composite View</b> suggests composing a View from numerous atomic pieces. Multiple smaller views, both static and dynamic, are pieced together to create a single template. The Service to Worker and Dispatcher View patterns represent a common combination of other patterns from the catalog. The two patterns share a common structure, consisting of a controller working with a Dispatcher, Views, and Helpers. Service to Worker and Dispatcher View have similar participant roles, but differ in the division of labor among those roles. Unlike Service to Worker, Dispatcher View defers business processing until view processing has been performed.<br/></li>
<li><b>Business Delegate</b> reduces coupling between remote tiers and provides an entry point for accessing remote services in the business tier. A Business Delegate might also cache data as necessary to improve performance. A Business Delegate encapsulates a Session Façade and maintains a one-to-one relationship with that Session Façade. An Application Service uses a Business Delegate to invoke a Session Façade.<br/></li>
<li><b>Service Locator</b> encapsulates the implementation mechanisms for looking up business service components. A Business Delegate uses a Service Locator to connect to a Session Façade. Other clients that need to locate and connect to Session Façade, other business-tier services, and web services can use a Service Locator.<br/></li>
<li><b>Session Façade</b> provides coarse-grained services to the clients by hiding the complexities of the business service interactions. A Session Façade might invoke several Application Service implementations or Business Objects. A Session Façade can also encapsulate a Value List Handler.<br/></li>
<li><b>Application Service</b> centralizes and aggregates behavior to provide a uniform service layer to the business tier services. An Application Service might interact with other services or Business Objects. An Application Service can invoke other Application Services and thus create a layer of services in your application.<br/></li>
<li><b>Business Object</b> implements your conceptual domain model using an object model. Business Objects separate business data and logic into a separate layer in your application. Business Objects typically represent persistent objects and can be transparently persisted using Domain Store.<br/></li>
<li><b>Composite Entity</b> implements a Business Object using local entity beans and POJOs. When implemented with bean-managed persistence, a Composite Entity uses Data Access Objects to facilitate persistence.<br/></li>
<li><b>The Transfer Object</b> pattern provides the best techniques and strategies to exchange data across tiers (that is, across system boundaries) to reduce the network overhead by minimizing the number of calls to get data from another tier.<br/></li>
<li><b>The Transfer Object Assembler</b> constructs a composite Transfer Object from various sources. These sources could be EJB components, Data Access Objects, or other arbitrary Java objects. This pattern is most useful when the client needs to obtain data for the application model or part of the model.<br/></li>
<li><b>The Value List Handler</b> uses the GoF iterator pattern to provide query execution and processing services. The Value List Handler caches the results of the query execution and return subsets of the result to the clients as requested. By using this pattern, it is possible to avoid overheads associated with finding large numbers of entity beans. The Value List Handler uses a Data Access Object to execute a query and fetch the results from a persistent store.<br/></li>
<li><b>Data Access Object</b> enables loose coupling between the business and resource tiers. Data Access Object encapsulates all the data access logic to create, retrieve, delete, and update data from a persistent store. Data Access Object uses Transfer Object to send and receive data.<br/></li>
<li><b>Service Activator</b> enables asynchronous processing in your enterprise applications using JMS. A Service Activator can invoke Application Service, Session Façade or Business Objects. You can also use several Service Activators to provide parallel asynchronous processing for long running tasks.<br/></li>
<li><b>Domain Store</b> provides a powerful mechanism to implement transparent persistence for your object model. It combines and links several other patterns including Data Access Objects.<br/></li>
<li><b>Web Service Broker</b> exposes and brokers one or more services in your application to external clients as a web service using XML and standard web protocols. A Web Service Broker can interact with Application Service and Session Façade. A Web Service Broker uses one or more Service Activators to perform asynchronous processing of a request.</li>
</ul>]]></answer>
		</qa>
	</category>
</questionbank>
