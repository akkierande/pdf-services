<questionbank group="Database">
	<category name="Sql">
		<qa id="1" rating="1">			<question><![CDATA[q:What is SQL?]]></question>
			<answer><![CDATA[SQL stands for 'Structured Query Language'.]]></answer>
		</qa>
		<qa id="2" rating="1">			<question><![CDATA[q:What is SELECT statement?]]></question>
			<answer><![CDATA[The SELECT statement lets you select a set of values from a table in a database. The values selected from the database table would depend on the various conditions that are specified in the SQL query.]]></answer>
		</qa>
		<qa id="3" rating="2">			<question><![CDATA[q:How can you compare a part of the name rather than the entire name?]]></question>
			<answer><![CDATA[SELECT * FROM people WHERE empname LIKE '%ab%'
Would return a recordset with records consisting empname the sequence 'ab' in empname .]]></answer>
		</qa>
		<qa id="4" rating="1">			<question><![CDATA[q:What is the INSERT statement?]]></question>
			<answer><![CDATA[The INSERT statement lets you insert information into a database.]]></answer>
		</qa>
		<qa id="5" rating="1">			<question><![CDATA[q:How do you delete a record from a database?]]></question>
			<answer><![CDATA[Use the DELETE statement to remove records or any particular column values from a database.]]></answer>
		</qa>
		<qa id="6" rating="2">			<question><![CDATA[q:How could I get distinct entries from a table?]]></question>
			<answer><![CDATA[The SELECT statement in conjunction with DISTINCT lets you select a set of distinct values from a table in a database. The values selected from the database table would of course depend on the various conditions that are specified in the SQL query. Example
SELECT DISTINCT empname FROM emptable]]></answer>
		</qa>
		<qa id="7" rating="2">			<question><![CDATA[q:How to get the results of a Query sorted in any order?]]></question>
			<answer><![CDATA[You can sort the results and return the sorted results to your program by using ORDER BY keyword thus saving you the pain of carrying out the sorting yourself. The ORDER BY keyword is used for sorting.

SELECT empname, age, city FROM emptable ORDER BY empname]]></answer>
		</qa>
		<qa id="8" rating="2">			<question><![CDATA[q:How can I find the total number of records in a table?]]></question>
			<answer><![CDATA[You could use the COUNT keyword , example
SELECT COUNT(*) FROM emp WHERE age>40]]></answer>
		</qa>
		<qa id="9" rating="2">			<question><![CDATA[q: Differentiate Having clause and Where clause?]]></question>
			<answer><![CDATA[<pre>
Both are used for filtering of records based on filtered criteria.
Having is used in a "group by" clause in a query.
"Where clause" has preference over "having clause" in a query.
Having Clause: This clause is used for specifying a search condition for a group or an aggregate. It can only be used with a SELECT statement. It"s often used with GROUP BY clause without which its synonymous to a WHERE clause.

E.g.: SELECT Id, Name, Age FROM Customers
GROUP BY Age
HAVING Age>10
ORDER BYAge;

Where Clause: This clause is used to narrow down the dataset being dealt with following a condition.

SELECT Id, Name, Age FROM Customers
WHERE Age>10

It is strongly recommended to use a Where clause with every Select Statement to avoid a table scan and reduce the number of rows to be returned. It can be used with Select, Update, Delete etc statements 	

,/pre>]]></answer>
		</qa>
		<qa id="10" rating="2">			<question><![CDATA[q:What is GROUP BY?]]></question>
			<answer><![CDATA[The GROUP BY keywords have been added to SQL because aggregate functions (like SUM) return the aggregate of all column values every time they are called. Without the GROUP BY functionality, finding the sum for each individual group of column values was not possible.]]></answer>
		</qa>
		<qa id="11" rating="2">			<question><![CDATA[q:What is the difference among "dropping a table", "truncating a table" and "deleting all records" from a table.]]></question>
			<answer><![CDATA[Dropping :  (Table structure  + Data are deleted), Invalidates the dependent objects ,Drops the indexes
Truncating:  (Data alone deleted), Performs an automatic commit, Faster than delete
Delete : (Data alone deleted), Doesn't perform automatic commit]]></answer>
		</qa>
		<qa id="12" rating="2">			<question><![CDATA[q:What are the Large object types suported by Oracle?]]></question>
			<answer><![CDATA[Blob and Clob.]]></answer>
		</qa>
		<qa id="13" rating="2">			<question><![CDATA[q:Difference between a "where" clause and a "having" clause.]]></question>
			<answer><![CDATA[Having clause is used only with group functions whereas Where is not used with.]]></answer>
		</qa>
		<qa id="14" rating="2">			<question><![CDATA[q:What's the difference between a primary key and a unique key?]]></question>
			<answer><![CDATA[Both primary key and unique enforce uniqueness of the column on which they are defined. But by default primary key creates a clustered index on the column, where are unique creates a nonclustered index by default. Another major difference is that, primary key doesn't allow NULLs, but unique key allows one NULL only.]]></answer>
		</qa>
		<qa id="15" rating="2">			<question><![CDATA[q:What are cursors? Explain different types of cursors. What are the disadvantages of cursors? How can you avoid cursors?]]></question>
			<answer><![CDATA[Cursors allow row-by-row prcessing of the resultsets.

* Types of cursors: Static, Dynamic, Forward-only, Keyset-driven. See books online for more information.

* Disadvantages of cursors: Each time you fetch a row from the cursor, it results in a network roundtrip, where as a normal SELECT query makes only one rowundtrip, however large the resultset is. Cursors are also costly because they require more resources and temporary storage (results in more IO operations). Furthere, there are restrictions on the SELECT statements that can be used with some types of cursors.

* Most of the times, set based operations can be used instead of cursors.]]></answer>
		</qa>
		<qa id="16" rating="2">			<question><![CDATA[q:What are triggers? How to invoke a trigger on demand?]]></question>
			<answer><![CDATA[Triggers are special kind of stored procedures that get executed automatically when an INSERT, UPDATE or DELETE operation takes place on a table. 
Triggers can't be invoked on demand. They get triggered only when an associated action (INSERT, UPDATE, DELETE) happens on the table on which they are defined.

Triggers are generally used to implement business rules, auditing. Triggers can also be used to extend the referential integrity checks, but wherever possible, use constraints for this purpose, instead of triggers, as constraints are much faster.]]></answer>
		</qa>
		<qa id="17" rating="2">			<question><![CDATA[q:What is a join and explain different types of joins.]]></question>
			<answer><![CDATA[Joins are used in queries to explain how different tables are related. Joins also let you select data from a table depending upon data from another table.

Types of joins: INNER JOINs, OUTER JOINs, CROSS JOINs. OUTER JOINs are further classified as LEFT OUTER JOINS, RIGHT OUTER JOINS and FULL OUTER JOINS.]]></answer>
		</qa>
		<qa id="18" rating="2">			<question><![CDATA[q: What is outer join? Explain Left outer join, Right outer join and Full outer join.]]></question>
			<answer><![CDATA[<pre>
OUTER JOIN: In An outer join, rows are returned even when there are no matches through the JOIN criteria on the second table.

LEFT OUTER JOIN: A left outer join or a left join returns results from the table mentioned on the left of the join irrespective of whether it finds matches or not. If the ON clause matches 0 records from table on the right, it will still return a row in the result—but with NULL in each column.

Example: To display employees irrespective of whether they have got bonus. 
Select * From employee LEFT OUTER JOIN bonus ON employee.bonusID=bonus.bonusID

RIGHT OUTER JOIN: A right outer join or a right join returns results from the table mentioned on the right of the join irrespective of whether it finds matches or not. If the ON clause matches 0 records from table on the left, it will still return a row in the result—but with NULL in each column.

Example: To display Bonus irrespective of whether they are an employee or not.
Select * From employee RIGHT OUTER JOIN bonus ON employee.bonusID=bonus.bonusID

FULL OUTER JOIN: A full outer join will combine results of both left and right outer join. Hence the records from both tables will be displayed with a NULL for missing matches from either of the tables.

Example: To display employees who have a bonus and to display bonus even if he is not an employee.
Select * From employee FULL OUTER JOIN bonus ON employee.bonusID=bonus.bonusID
</pre>]]></answer>
		</qa>
		<qa id="19" rating="2">			<question><![CDATA[q:What is a self join?]]></question>
			<answer><![CDATA[Self join is just like any other join, except that two instances of the same table will be joined in the query.]]></answer>
		</qa>
		<qa id="20" rating="3">			<question><![CDATA[q:What is index? Define its types.]]></question>
			<answer><![CDATA[Index is created on a column in tables. It helps in providing fast access to data based on the values stored in the column.

E.g.: If an index is created on primary key of a table and then search for a row based on primary key value then SQL Server first finds that value in the index and then uses the index to locate the row in the table instead of performing a complete table scan.

Types of indexes:
* Clustered: Stores the actual row at the leaf level of the index.
* Nonclustered: Stores only the values from the indexed column and row locators that point to the actual row at leaf level instead of the actual row itself.
* Composite: Index containing more than one column (max 16).
* Unique: Ensures the uniqueness of each value in the indexed column.]]></answer>
		</qa>
	</category>
	<category name="Transaction">
		<qa id="21" rating="2">			<question><![CDATA[q:Define transaction and its properties?]]></question>
			<answer><![CDATA[A transaction is a set of operations that works as a single unit. The transactions can be categorized into explicit, autocommit, and implicit transactions. Every transaction should follow four properties called the ACID properties i.e. atomicity, consistency, isolation, and durability.

Atomicity
Transaction ensures either modification is committed or not committed.

Consistency
The data should be in consistent state when transaction process is completed. This means that all related tables are updated.

Isolation
SQL server supports concurrency when mean that data can be access or shared by many users. A transaction works in isolation and doesn"t allow other transaction to work concurrently on the same piece of data.

Durability 
Data is permanent once transaction is completed and it can be recovered even if system fails.]]></answer>
		</qa>
		<qa id="22" rating="3">			<question><![CDATA[q:Define transaction isolation levels]]></question>
			<answer><![CDATA[There are four transaction isolation levels:
<pre>
1. Read uncommitted isolation levels
This is the lowest isolation level which can also be called as dirty read. Using this, you can read uncommitted data which can be rolled back at any point. With this level, SQL server uses share lock while reading data.

2. Read committed isolation levels
With this level, uncommitted data can"t be read. This is default isolation level and uses shared lock while reading data.

3. Repeatable read isolation levels
It locks all the data that is used in the query.

4.Serializable isolation levels 
It locks data set until the transaction will be completed
</pre>]]></answer>
		</qa>
		<qa id="23" rating="3">			<question><![CDATA[q:What is Isolation Levels?]]></question>
			<answer><![CDATA[Isolation keeps the transactions of multiple users isolated from each other. Transaction isolation level controls the degree of locking which occurs when selecting data. This is necessary to avoid situations like:

Lost updates- when two transactions read the same data.
Dirty read- Occurs when a transaction reads data that has not been updated.
Non repeatable reads- occur when different results are read multiple times.
Phantoms- Occurs when row data matches the first time but does not match subsequent times.]]></answer>
		</qa>
	</category>
</questionbank>
